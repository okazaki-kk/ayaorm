// Code generated by ayaorm. DO NOT EDIT.
package main

import (
	"fmt"
	"github.com/okazaki-kk/ayaorm"
)

type UserRelation struct {
	model *User
	*ayaorm.Relation
}

func (m *User) newRelation() *UserRelation {
	r := &UserRelation{
		m,
		ayaorm.NewRelation(db).SetTable("users"),
	}
	r.Select(
		"id",
		"name",
		"age",
	)

	return r
}

func (m User) Select(columns ...string) *UserRelation {
	return m.newRelation().Select(columns...)
}

func (r *UserRelation) Select(columns ...string) *UserRelation {
	cs := []string{}
	for _, c := range columns {
		if r.model.isColumnName(c) {
			cs = append(cs, fmt.Sprintf("users.%s", c))
		} else {
			cs = append(cs, c)
		}
	}
	r.Relation.SetColumns(cs...)
	return r
}

type UserParams User

func (m User) Build(p UserParams) *User {
	return &User{
		Id:   p.Id,
		Name: p.Name,
		Age:  p.Age,
	}
}

func (r *UserRelation) QueryRow() (*User, error) {
	row := &User{}
	err := r.Relation.QueryRow(row.fieldPtrsByName(r.Relation.GetColumns())...)
	if err != nil {
		return nil, err
	}
	return row, nil
}

func (m User) Count(column ...string) int {
	return m.newRelation().Count(column...)
}

func (m User) All() *UserRelation {
	return m.newRelation()
}

func (m User) Limit(limit int) *UserRelation {
	return m.newRelation().Limit(limit)
}

func (r *UserRelation) Limit(limit int) *UserRelation {
	r.Relation.Limit(limit)
	return r
}

func (m User) Order(key, order string) *UserRelation {
	return m.newRelation().Order(key, order)
}

func (r *UserRelation) Order(key, order string) *UserRelation {
	r.Relation.Order(key, order)
	return r
}

func (m User) Where(column string, value interface{}) *UserRelation {
	return m.newRelation().Where(column, value)
}

func (r *UserRelation) Where(column string, value interface{}) *UserRelation {
	r.Relation.Where(column, value)
	return r
}

func (m User) Save() error {
	return m.newRelation().Save()
}

func (r *UserRelation) Save() error {
	fieldMap := make(map[string]interface{})
	for _, c := range r.Relation.GetColumns() {
		switch c {
		case "name", "users.name":
			fieldMap["name"] = r.model.Name
		case "age", "users.age":
			fieldMap["age"] = r.model.Age
		}
	}

	return r.Relation.Save(fieldMap)
}

func (m User) First() *UserRelation {
	return m.newRelation().First()
}

func (r *UserRelation) First() *UserRelation {
	r.Relation.First()
	return r
}

func (m User) Last() *UserRelation {
	return m.newRelation().Last()
}

func (r *UserRelation) Last() *UserRelation {
	r.Relation.Last()
	return r
}

func (m User) Find(id int) *UserRelation {
	return m.newRelation().Find(id)
}

func (r *UserRelation) Find(id int) *UserRelation {
	r.Relation.Find(id)
	return r
}

func (m User) FindBy(column string, value interface{}) *UserRelation {
	return m.newRelation().FindBy(column, value)
}

func (r *UserRelation) FindBy(column string, value interface{}) *UserRelation {
	r.Relation.FindBy(column, value)
	return r
}

func (r *UserRelation) Query() ([]*User, error) {
	rows, err := r.Relation.Query()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []*User{}
	for rows.Next() {
		row := &User{}
		err := rows.Scan(row.fieldPtrsByName(r.Relation.GetColumns())...)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func (m *User) fieldPtrByName(name string) interface{} {
	switch name {
	case "id", "users.id":
		return &m.Id
	case "name", "users.name":
		return &m.Name
	case "age", "users.age":
		return &m.Age
	default:
		return nil
	}
}

func (m *User) fieldPtrsByName(names []string) []interface{} {
	fields := []interface{}{}
	for _, n := range names {
		f := m.fieldPtrByName(n)
		fields = append(fields, f)
	}
	return fields
}

func (m *User) isColumnName(name string) bool {
	for _, c := range m.columnNames() {
		if c == name {
			return true
		}
	}
	return false
}

func (m *User) columnNames() []string {
	return []string{
		"id",
		"name",
		"age",
	}
}
